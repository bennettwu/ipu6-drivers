diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index 3a5111e41917..cfd8ca47b3c3 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -43,6 +43,7 @@
 			    (pdev)->device == 0x9a39 ||		\
 			    (pdev)->device == 0x4e19 ||		\
 			    (pdev)->device == 0x465d ||		\
+			    (pdev)->device == 0x7d19 ||		\
 			    (pdev)->device == 0x1919))
 #define IS_AZALIA(pdev) ((pdev)->vendor == 0x8086 && (pdev)->device == 0x3a3e)
 
diff --git a/drivers/media/i2c/ov13b10.c b/drivers/media/i2c/ov13b10.c
index 7caeae641051..16446f99c4a1 100644
--- a/drivers/media/i2c/ov13b10.c
+++ b/drivers/media/i2c/ov13b10.c
@@ -2,6 +2,8 @@
 // Copyright (c) 2021 Intel Corporation.
 
 #include <linux/acpi.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
@@ -79,6 +81,17 @@
 /* Vertical Window Offset */
 #define OV13B10_REG_V_WIN_OFFSET	0x3813
 
+/* The clock source index in INT3472 CLDB */
+#define INT3472_CLDB_CLKSRC_INDEX 	14
+
+/*
+ * 82c0d13a-78c5-4244-9bb1-eb8b539a8d11
+ * This _DSM GUID calls CLKC and CLKF.
+ */
+static const guid_t clock_ctrl_guid =
+	GUID_INIT(0x82c0d13a, 0x78c5, 0x4244,
+		  0x9b, 0xb1, 0xeb, 0x8b, 0x53, 0x9a, 0x8d, 0x11);
+
 struct ov13b10_reg {
 	u16 address;
 	u8 val;
@@ -569,6 +582,21 @@ static const struct ov13b10_mode supported_modes[] = {
 	}
 };
 
+struct ov13b10_power_ctrl {
+	/* Control Logic ACPI device */
+	struct acpi_device *ctrl_logic;
+	/* GPIO for reset */
+	struct gpio_desc *reset_gpio;
+	/* GPIO for power enable */
+	struct gpio_desc *pwren_gpio;
+	/* GPIO for privacy LED */
+	struct gpio_desc *pled_gpio;
+
+	int status;
+	/* Clock source index */
+	u8 clk_source_index;
+};
+
 struct ov13b10 {
 	struct v4l2_subdev sd;
 	struct media_pad pad;
@@ -587,17 +615,159 @@ struct ov13b10 {
 	/* Mutex for serialized access */
 	struct mutex mutex;
 
+	struct ov13b10_power_ctrl power;
+
+	/* i2c client */
+	struct i2c_client *client;
+
 	/* Streaming on/off */
 	bool streaming;
 };
 
 #define to_ov13b10(_sd)	container_of(_sd, struct ov13b10, sd)
 
+static struct gpio_desc* ov13b10_get_gpio(struct ov13b10 *ov13b10,
+					  const char* name)
+{
+	struct device *dev = &ov13b10->client->dev;
+	struct gpio_desc* gpio;
+	int ret;
+
+	gpio = devm_gpiod_get(dev, name, GPIOD_OUT_HIGH);
+	ret = PTR_ERR_OR_ZERO(gpio);
+	if (ret < 0) {
+		gpio = NULL;
+		dev_warn(dev, "failed to get %s gpio: %d\n", name, ret);
+	}
+
+	return gpio;
+}
+
+static void ov13b10_init_power_ctrl(struct ov13b10 *ov13b10)
+{
+	struct ov13b10_power_ctrl* power = &ov13b10->power;
+	acpi_handle handle = ACPI_HANDLE(&ov13b10->client->dev);
+	struct acpi_handle_list dep_devices;
+	acpi_status status;
+	int i = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+
+	power->ctrl_logic = NULL;
+	if (!acpi_has_method(handle, "_DEP"))
+		return;
+
+	/* Call _DEP method of OV13B */
+	status = acpi_evaluate_reference(handle, "_DEP", NULL, &dep_devices);
+	if (ACPI_FAILURE(status)) {
+		acpi_handle_debug(handle, "Failed to evaluate _DEP.\n");
+		return;
+	}
+
+	/* Find INT3472 in _DEP */
+	for (i = 0; i < dep_devices.count; i++) {
+		struct acpi_device *dep_device = NULL;
+		const char* dep_hid = NULL;
+
+		if (dep_devices.handles[i])
+			dep_device =
+				acpi_fetch_acpi_dev(dep_devices.handles[i]);
+		if (dep_device)
+			dep_hid = acpi_device_hid(dep_device);
+		if (dep_hid && strcmp("INT3472", dep_hid) == 0) {
+			power->ctrl_logic = dep_device;
+			break;
+		}
+	}
+
+	/* If we got INT3472 acpi device, read which clock source we'll use */
+	if (power->ctrl_logic == NULL)
+		return;
+	status = acpi_evaluate_object(power->ctrl_logic->handle,
+				      "CLDB", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		dev_warn(&ov13b10->client->dev, "Read INT3472 CLDB failed");
+		return;
+	}
+
+	obj = buffer.pointer;
+	if (!obj) {
+		dev_warn(&ov13b10->client->dev, "INT3472 CLDB return NULL");
+		return;
+	}
+	if (obj->type != ACPI_TYPE_BUFFER) {
+		acpi_handle_err(power->ctrl_logic->handle,
+				"CLDB object is not an ACPI buffer\n");
+		kfree(obj);
+		return;
+	}
+	if (obj->buffer.length < INT3472_CLDB_CLKSRC_INDEX + 1) {
+		acpi_handle_err(power->ctrl_logic->handle,
+				"The CLDB buffer size is wrong\n");
+		kfree(obj);
+		return;
+	}
+
+	/* Get the clock source index */
+	ov13b10->power.clk_source_index =
+		obj->buffer.pointer[INT3472_CLDB_CLKSRC_INDEX];
+	kfree(obj);
+
+	/* Get gpios mapped by INT3472 driver */
+	power->reset_gpio = ov13b10_get_gpio(ov13b10, "reset");
+	power->pwren_gpio = ov13b10_get_gpio(ov13b10, "pwren");
+	power->pled_gpio = ov13b10_get_gpio(ov13b10, "pled");
+	power->status = 0;
+}
+
+static void ov13b10_set_power(struct ov13b10 *ov13b10, int on)
+{
+	struct ov13b10_power_ctrl* power = &ov13b10->power;
+
+	on = (on ? 1 : 0);
+	if (on == power->status)
+		return;
+
+	/* First, set reset pin as low */
+	if (power->reset_gpio) {
+		gpiod_set_value_cansleep(power->reset_gpio, 0);
+		msleep(5);
+	}
+
+	/* Use _DSM of INT3472 to enable clock */
+	if (power->ctrl_logic) {
+		u8 clock_args[] = { power->clk_source_index, on, 0x01,};
+		union acpi_object clock_ctrl_args = {
+			.buffer = {
+				.type = ACPI_TYPE_BUFFER,
+				.length = 3,
+				.pointer = clock_args,
+			},
+		};
+		acpi_evaluate_dsm(power->ctrl_logic->handle,
+				  &clock_ctrl_guid, 0x00, 0x01,
+				  &clock_ctrl_args);
+	}
+
+	/* Set power pin and privacy LED pin */
+	if (power->pwren_gpio)
+		gpiod_set_value_cansleep(power->pwren_gpio, on);
+	if (power->pled_gpio)
+		gpiod_set_value_cansleep(power->pled_gpio, on);
+
+	/* If we need to power on, set reset pin to high at last */
+	if (on && power->reset_gpio) {
+		gpiod_set_value_cansleep(power->reset_gpio, 1);
+		msleep(5);
+	}
+	power->status = on;
+}
+
 /* Read registers up to 4 at a time */
 static int ov13b10_read_reg(struct ov13b10 *ov13b,
 			    u16 reg, u32 len, u32 *val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	struct i2c_msg msgs[2];
 	u8 *data_be_p;
 	int ret;
@@ -633,7 +803,7 @@ static int ov13b10_read_reg(struct ov13b10 *ov13b,
 static int ov13b10_write_reg(struct ov13b10 *ov13b,
 			     u16 reg, u32 len, u32 __val)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	int buf_i, val_i;
 	u8 buf[6], *val_p;
 	__be32 val;
@@ -662,7 +832,7 @@ static int ov13b10_write_reg(struct ov13b10 *ov13b,
 static int ov13b10_write_regs(struct ov13b10 *ov13b,
 			      const struct ov13b10_reg *regs, u32 len)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	int ret;
 	u32 i;
 
@@ -826,7 +996,7 @@ static int ov13b10_set_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ov13b10 *ov13b = container_of(ctrl->handler,
 					     struct ov13b10, ctrl_handler);
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	s64 max;
 	int ret;
 
@@ -1025,10 +1195,11 @@ ov13b10_set_pad_format(struct v4l2_subdev *sd,
 
 static int ov13b10_start_streaming(struct ov13b10 *ov13b)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	const struct ov13b10_reg_list *reg_list;
 	int ret, link_freq_index;
 
+	ov13b10_set_power(ov13b, 1);
 	/* Get out of from software reset */
 	ret = ov13b10_write_reg(ov13b, OV13B10_REG_SOFTWARE_RST,
 				OV13B10_REG_VALUE_08BIT, OV13B10_SOFTWARE_RST);
@@ -1065,16 +1236,20 @@ static int ov13b10_start_streaming(struct ov13b10 *ov13b)
 }
 
 /* Stop streaming */
-static int ov13b10_stop_streaming(struct ov13b10 *ov13b)
+static void ov13b10_stop_streaming(struct ov13b10 *ov13b)
 {
-	return ov13b10_write_reg(ov13b, OV13B10_REG_MODE_SELECT,
-				 OV13B10_REG_VALUE_08BIT, OV13B10_MODE_STANDBY);
+	struct i2c_client *client = ov13b->client;
+
+	if (ov13b10_write_reg(ov13b, OV13B10_REG_MODE_SELECT,
+			     OV13B10_REG_VALUE_08BIT, OV13B10_MODE_STANDBY))
+		dev_err(&client->dev, "failed to stop streaming");
+	ov13b10_set_power(ov13b, 0);
 }
 
 static int ov13b10_set_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct ov13b10 *ov13b = to_ov13b10(sd);
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = ov13b->client;
 	int ret = 0;
 
 	mutex_lock(&ov13b->mutex);
@@ -1147,7 +1322,7 @@ static int __maybe_unused ov13b10_resume(struct device *dev)
 /* Verify chip ID */
 static int ov13b10_identify_module(struct ov13b10 *ov13b)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	int ret;
 	u32 val;
 
@@ -1192,7 +1367,7 @@ static const struct v4l2_subdev_internal_ops ov13b10_internal_ops = {
 /* Initialize control handlers */
 static int ov13b10_init_controls(struct ov13b10 *ov13b)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(&ov13b->sd);
+	struct i2c_client *client = ov13b->client;
 	struct v4l2_fwnode_device_properties props;
 	struct v4l2_ctrl_handler *ctrl_hdlr;
 	s64 exposure_max;
@@ -1306,92 +1481,19 @@ static void ov13b10_free_controls(struct ov13b10 *ov13b)
 	mutex_destroy(&ov13b->mutex);
 }
 
-static int ov13b10_check_hwcfg(struct device *dev)
-{
-	struct v4l2_fwnode_endpoint bus_cfg = {
-		.bus_type = V4L2_MBUS_CSI2_DPHY
-	};
-	struct fwnode_handle *ep;
-	struct fwnode_handle *fwnode = dev_fwnode(dev);
-	unsigned int i, j;
-	int ret;
-	u32 ext_clk;
-
-	if (!fwnode)
-		return -ENXIO;
-
-	ret = fwnode_property_read_u32(dev_fwnode(dev), "clock-frequency",
-				       &ext_clk);
-	if (ret) {
-		dev_err(dev, "can't get clock frequency");
-		return ret;
-	}
-
-	if (ext_clk != OV13B10_EXT_CLK) {
-		dev_err(dev, "external clock %d is not supported",
-			ext_clk);
-		return -EINVAL;
-	}
-
-	ep = fwnode_graph_get_next_endpoint(fwnode, NULL);
-	if (!ep)
-		return -ENXIO;
-
-	ret = v4l2_fwnode_endpoint_alloc_parse(ep, &bus_cfg);
-	fwnode_handle_put(ep);
-	if (ret)
-		return ret;
-
-	if (bus_cfg.bus.mipi_csi2.num_data_lanes != OV13B10_DATA_LANES) {
-		dev_err(dev, "number of CSI2 data lanes %d is not supported",
-			bus_cfg.bus.mipi_csi2.num_data_lanes);
-		ret = -EINVAL;
-		goto out_err;
-	}
-
-	if (!bus_cfg.nr_of_link_frequencies) {
-		dev_err(dev, "no link frequencies defined");
-		ret = -EINVAL;
-		goto out_err;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(link_freq_menu_items); i++) {
-		for (j = 0; j < bus_cfg.nr_of_link_frequencies; j++) {
-			if (link_freq_menu_items[i] ==
-				bus_cfg.link_frequencies[j])
-				break;
-		}
-
-		if (j == bus_cfg.nr_of_link_frequencies) {
-			dev_err(dev, "no link frequency %lld supported",
-				link_freq_menu_items[i]);
-			ret = -EINVAL;
-			goto out_err;
-		}
-	}
-
-out_err:
-	v4l2_fwnode_endpoint_free(&bus_cfg);
-
-	return ret;
-}
-
 static int ov13b10_probe(struct i2c_client *client)
 {
 	struct ov13b10 *ov13b;
 	int ret;
 
-	/* Check HW config */
-	ret = ov13b10_check_hwcfg(&client->dev);
-	if (ret) {
-		dev_err(&client->dev, "failed to check hwcfg: %d", ret);
-		return ret;
-	}
-
 	ov13b = devm_kzalloc(&client->dev, sizeof(*ov13b), GFP_KERNEL);
 	if (!ov13b)
 		return -ENOMEM;
 
+	ov13b->client = client;
+	ov13b10_init_power_ctrl(ov13b);
+	ov13b10_set_power(ov13b, 1);
+
 	/* Initialize subdev */
 	v4l2_i2c_subdev_init(&ov13b->sd, client, &ov13b10_subdev_ops);
 
@@ -1434,6 +1536,7 @@ static int ov13b10_probe(struct i2c_client *client)
 	pm_runtime_set_active(&client->dev);
 	pm_runtime_enable(&client->dev);
 	pm_runtime_idle(&client->dev);
+	ov13b10_set_power(ov13b, 0);
 
 	return 0;
 
@@ -1443,6 +1546,7 @@ static int ov13b10_probe(struct i2c_client *client)
 error_handler_free:
 	ov13b10_free_controls(ov13b);
 	dev_err(&client->dev, "%s failed:%d\n", __func__, ret);
+	ov13b10_set_power(ov13b, 0);
 
 	return ret;
 }
@@ -1468,6 +1572,7 @@ static const struct dev_pm_ops ov13b10_pm_ops = {
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id ov13b10_acpi_ids[] = {
 	{"OVTIDB10"},
+	{"OVTI13B1"},
 	{ /* sentinel */ }
 };
 
diff --git a/drivers/platform/x86/intel/int3472/common.h b/drivers/platform/x86/intel/int3472/common.h
index 53270d19c73a..7350a3840438 100644
--- a/drivers/platform/x86/intel/int3472/common.h
+++ b/drivers/platform/x86/intel/int3472/common.h
@@ -23,7 +23,7 @@
 #define INT3472_GPIO_TYPE_PRIVACY_LED				0x0d
 
 #define INT3472_PDEV_MAX_NAME_LEN				23
-#define INT3472_MAX_SENSOR_GPIOS				3
+#define INT3472_MAX_SENSOR_GPIOS				4
 
 #define GPIO_REGULATOR_NAME_LENGTH				21
 #define GPIO_REGULATOR_SUPPLY_NAME_LENGTH			9
@@ -73,6 +73,7 @@ struct int3472_sensor_config {
 	const char *sensor_module_name;
 	struct regulator_consumer_supply supply_map;
 	const struct int3472_gpio_function_remap *function_maps;
+	const bool use_independent_gpio;
 };
 
 struct int3472_discrete_device {
diff --git a/drivers/platform/x86/intel/int3472/discrete.c b/drivers/platform/x86/intel/int3472/discrete.c
index ed4c9d760757..8b39d6656502 100644
--- a/drivers/platform/x86/intel/int3472/discrete.c
+++ b/drivers/platform/x86/intel/int3472/discrete.c
@@ -57,11 +57,19 @@ static const struct int3472_gpio_function_remap ov2680_gpio_function_remaps[] =
 
 static const struct int3472_sensor_config int3472_sensor_configs[] = {
 	/* Lenovo Miix 510-12ISK - OV2680, Front */
-	{ "GNDF140809R", { 0 }, ov2680_gpio_function_remaps },
+	{ "GNDF140809R", { 0 }, ov2680_gpio_function_remaps, false },
 	/* Lenovo Miix 510-12ISK - OV5648, Rear */
-	{ "GEFF150023R", REGULATOR_SUPPLY("avdd", NULL), NULL },
+	{ "GEFF150023R", REGULATOR_SUPPLY("avdd", NULL), NULL, false },
 	/* Surface Go 1&2 - OV5693, Front */
-	{ "YHCU", REGULATOR_SUPPLY("avdd", NULL), NULL },
+	{ "YHCU", REGULATOR_SUPPLY("avdd", NULL), NULL, false },
+	/* Dell Latitude 9420 - OV01A1S, Front */
+	{ "0BF111N3", { 0 }, NULL, true },
+	/* Dell Latitude 9420 - HM11B1, Front */
+	{ "9BF123N3", { 0 }, NULL, true },
+	/* Lenovo X1 Yoga - OV2740, Front */
+	{ "CJFLE23", { 0 }, NULL, true },
+	/* OV13B10 */
+	{ "09B13", { 0 }, NULL, true },
+       /* HIMX1092 */
+       { "KPFB297", { 0 }, NULL, true },
+       /* GC5035 */
+       { "CJAK519", { 0 }, NULL, true },
+       /* S5K3L6 */
+       { "KBAG296", { 0 }, NULL, true },
 };
 
 static const struct int3472_sensor_config *
@@ -225,6 +233,8 @@ static int skl_int3472_handle_gpio_resources(struct acpi_resource *ares,
 	const char *err_msg;
 	int ret;
 	u8 type;
+	u8 active_value;
+	u32 polarity = GPIO_LOOKUP_FLAGS_DEFAULT;
 
 	if (!acpi_gpio_get_io_resource(ares, &agpio))
 		return 1;
@@ -245,30 +255,60 @@ static int skl_int3472_handle_gpio_resources(struct acpi_resource *ares,
 	}
 
 	type = obj->integer.value & 0xff;
+	active_value = obj->integer.value >> 24;
+	if (!active_value)
+		polarity = GPIO_ACTIVE_LOW;
 
 	switch (type) {
 	case INT3472_GPIO_TYPE_RESET:
 		ret = skl_int3472_map_gpio_to_sensor(int3472, agpio, "reset",
-						     GPIO_ACTIVE_LOW);
+						     polarity);
 		if (ret)
 			err_msg = "Failed to map reset pin to sensor\n";
 
 		break;
 	case INT3472_GPIO_TYPE_POWERDOWN:
 		ret = skl_int3472_map_gpio_to_sensor(int3472, agpio, "powerdown",
-						     GPIO_ACTIVE_LOW);
+						     polarity);
 		if (ret)
 			err_msg = "Failed to map powerdown pin to sensor\n";
 
 		break;
 	case INT3472_GPIO_TYPE_CLK_ENABLE:
+		if (!IS_ERR(int3472->sensor_config) &&
+		    int3472->sensor_config->use_independent_gpio) {
+			ret = skl_int3472_map_gpio_to_sensor(int3472, agpio,
+							     "clken", polarity);
+			if (ret)
+				err_msg = "Failed to map clken pin to sensor\n";
+
+			break;
+		}
 	case INT3472_GPIO_TYPE_PRIVACY_LED:
+		if (!IS_ERR(int3472->sensor_config) &&
+		    int3472->sensor_config->use_independent_gpio) {
+			ret = skl_int3472_map_gpio_to_sensor(int3472, agpio,
+							     "pled", polarity);
+			if (ret)
+				err_msg = "Failed to map pled pin to sensor\n";
+
+			break;
+		}
 		ret = skl_int3472_map_gpio_to_clk(int3472, agpio, type);
 		if (ret)
 			err_msg = "Failed to map GPIO to clock\n";
 
 		break;
 	case INT3472_GPIO_TYPE_POWER_ENABLE:
+		if (!IS_ERR(int3472->sensor_config) &&
+		    int3472->sensor_config->use_independent_gpio) {
+			ret = skl_int3472_map_gpio_to_sensor(int3472, agpio,
+							     "pwren", polarity);
+			if (ret)
+				err_msg = "Failed to map clken pin to sensor\n";
+
+			break;
+		}
 		ret = skl_int3472_register_regulator(int3472, agpio);
 		if (ret)
 			err_msg = "Failed to map regulator to sensor\n";
